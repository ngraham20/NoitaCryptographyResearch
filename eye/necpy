#!/usr/bin/env python

import json
from itertools import cycle, islice, chain
from ui import UI
from message import Message
from subcipher import SubCipher
from wheel import Wheel
from panel import Panel

def load_config(filename):
    f = open(filename)
    eyes=json.load(f)
    f.close()
    return eyes

def insert_every(lst, freq, item):
    for i in range(freq-1,len(lst),freq):
        lst.insert(i, item)

def handle_args(data):
    eyes = load_config(data["confjson"]) if 'confjson' in data else None
    history = None
    tasks = eyes.get("tasks", [])
    delimiter = eyes.get("delimiter")
    messages = [Message(k, v, delimiter) for i, (k, v) in enumerate(eyes.get("messages").items())]
    wheelgroups = eyes.get("wheels", [])
    fmt = eyes.get("format")
    style = eyes.get("style")
    for message in messages:
        for task in tasks:
            if task == "display":
                print(message.as_panel(UI.size, fmt, style))
            if task == "encrypt" or task == "decrypt":
                ciphernodes = [''.join(message.as_trigrams(style))]
                current_wheelgroup = 0
                ciphers = eyes.get("ciphers", [])
                cipherwheelgroups = list(zip(ciphers, list(islice(cycle(wheelgroups), len(ciphers)))))

                # Describe what will happen during cipher step
                modulepaneldata = ["Cipher " + str(i+1) + ": " + x[0] for i,x in enumerate(cipherwheelgroups)]
                wheelpaneldata = ["Wheel  " + str(i+1) + ": " + ' -> '.join(x[1]) for i,x in enumerate(cipherwheelgroups)]

                infopaneldata = list(chain.from_iterable(zip(modulepaneldata, wheelpaneldata)))
                # insert_every(infopaneldata, 3, '')
                print(Panel(infopaneldata, UI.size,1,"Encryption Order").with_groupsize(2))

                for ciphername in ciphers:
                    if ciphername == "substitution":
                        wheels = list(map(Wheel, wheelgroups[current_wheelgroup]))
                        # wow! using map with a constructor actually works!
                        current_wheelgroup = (current_wheelgroup + 1) % len(wheelgroups)
                        cipher = SubCipher(wheels)
                    ciphernodes.append(cipher.encode(ciphernodes[-1], history))

                cipherpaneldata = ["Encryption Step " + str(i) + ": " + x for i,x in enumerate(ciphernodes)]
                print(Panel(cipherpaneldata,UI.size,1,"Cipher Nodes"))
                
                if task == "encrypt":
                    resultpaneldata =  ["Plaintext:      " + ciphernodes[0]]
                    resultpaneldata += ["Ciphertext:     " + ciphernodes[-1]]
                if task == "decrypt":
                    resultpaneldata =  ["Ciphertext:      " + ciphernodes[0]]
                    resultpaneldata += ["Plaintext:       " + ciphernodes[-1]]
                print(Panel(resultpaneldata,UI.size,1,None,"Results"))

def main():

    UI.program_header()
    ea = UI.parse_args()
    handle_args(ea)

if __name__ == "__main__":
    main()